#!/usr/bin/env node

/**
 * SWAPS Algorithm Integration Scale Test
 * 
 * This script tests the actual trade algorithm implementation with the simulated
 * data generated by our scale test framework.
 */

const fs = require('fs');
const path = require('path');
const { TradeSimulation, DEFAULT_CONFIG } = require('./scale-test-algorithm');

// Import the actual algorithm implementations
const { TradeLoopFinderService } = require('./backend/src/services/trade/TradeLoopFinderService.ts');
const { TradeDiscoveryService } = require('./backend/src/services/trade/TradeDiscoveryService.ts');
const { GraphPartitioningService } = require('./backend/src/services/trade/GraphPartitioningService.ts');

// Simple colored output
const colors = {
  blue: (text) => `\x1b[34m${text}\x1b[0m`,
  red: (text) => `\x1b[31m${text}\x1b[0m`,
  green: (text) => `\x1b[32m${text}\x1b[0m`,
  yellow: (text) => `\x1b[33m${text}\x1b[0m`,
  cyan: (text) => `\x1b[36m${text}\x1b[0m`,
  magenta: (text) => `\x1b[35m${text}\x1b[0m`
};

class IntegrationScaleTest {
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.simulation = new TradeSimulation(this.config);
    this.algorithmStats = {
      totalTradesFound: 0,
      directTrades: 0,
      circularTrades: 0,
      complexTrades: 0,
      processingTime: 0,
      memoryUsage: {},
      tradesBySize: {},
      largestTradeSize: 0
    };
  }
  
  async run() {
    console.log(colors.blue(`=== SWAPS Algorithm Integration Scale Test ===`));
    console.log(colors.yellow(`Generating simulation data...`));
    
    // Generate simulation data
    await this.simulation.generateTestData();
    
    // Run the actual algorithm tests
    await this.runAlgorithmTests();
    
    // Print and save results
    this.printResults();
    this.saveResults();
    
    return this.algorithmStats;
  }
  
  async runAlgorithmTests() {
    console.log(colors.yellow(`\nRunning actual algorithm implementation on simulated data...`));
    
    try {
      // Initialize the actual algorithm services
      const graphPartitioning = new GraphPartitioningService();
      const tradeLoopFinder = new TradeLoopFinderService({
        maxDepth: this.config.algorithm.maxDepth,
        minEfficiency: this.config.algorithm.minEfficiency,
        timeout: this.config.algorithm.timeout
      });
      
      // Initialize the trade discovery service without persistence
      const tradeDiscovery = new TradeDiscoveryService({
        persistenceEnabled: false,
        graphPartitioning,
        tradeLoopFinder
      });
      
      // Convert simulated data to the format expected by the algorithm
      this.convertSimulationDataToAlgorithm(tradeDiscovery);
      
      // Run the algorithm for a sample of wallets
      console.log(colors.cyan(`\nTesting algorithm for ${Math.min(10, this.simulation.wallets.length)} random wallets...`));
      
      const startTime = Date.now();
      const memoryBefore = process.memoryUsage();
      
      // Sample up to 10 random wallets
      const sampleSize = Math.min(10, this.simulation.wallets.length);
      const sampleWallets = [];
      
      for (let i = 0; i < sampleSize; i++) {
        const randomIndex = Math.floor(Math.random() * this.simulation.wallets.length);
        sampleWallets.push(this.simulation.wallets[randomIndex]);
      }
      
      // Run algorithm for each sample wallet
      for (const wallet of sampleWallets) {
        console.log(colors.cyan(`\nFinding trades for wallet: ${wallet}`));
        
        try {
          // Find trade loops
          const results = await tradeDiscovery.findTradeLoops(wallet);
          
          // Process results
          const trades = results?.tradeLoops || [];
          
          console.log(`Found ${trades.length} trades`);
          
          // Update stats
          this.algorithmStats.totalTradesFound += trades.length;
          
          if (trades.length > 0) {
            // Analyze trade types
            for (const trade of trades) {
              const steps = trade.steps?.length || 0;
              
              // Categorize trade
              if (steps === 2) {
                this.algorithmStats.directTrades++;
              } else if (steps >= 3 && steps <= 6) {
                this.algorithmStats.circularTrades++;
              } else {
                this.algorithmStats.complexTrades++;
              }
              
              // Update size stats
              this.algorithmStats.tradesBySize[steps] = (this.algorithmStats.tradesBySize[steps] || 0) + 1;
              this.algorithmStats.largestTradeSize = Math.max(this.algorithmStats.largestTradeSize, steps);
              
              // Print trade details
              console.log(`- Trade with ${steps} steps and ${trade.totalParticipants || steps} participants`);
              console.log(`  Efficiency: ${trade.efficiency || 'N/A'}`);
              
              if (trade.steps) {
                for (let i = 0; i < trade.steps.length; i++) {
                  const step = trade.steps[i];
                  console.log(`  Step ${i+1}: ${step.from?.substring(0, 8)} â†’ ${step.to?.substring(0, 8)}`);
                }
              }
            }
          }
        } catch (error) {
          console.error(colors.red(`Error finding trades for wallet ${wallet}:`), error);
        }
      }
      
      const endTime = Date.now();
      const memoryAfter = process.memoryUsage();
      
      // Calculate processing time and memory usage
      this.algorithmStats.processingTime = endTime - startTime;
      this.algorithmStats.memoryUsage = {
        rss: memoryAfter.rss - memoryBefore.rss,
        heapTotal: memoryAfter.heapTotal - memoryBefore.heapTotal,
        heapUsed: memoryAfter.heapUsed - memoryBefore.heapUsed,
        external: memoryAfter.external - memoryBefore.external
      };
      
      console.log(colors.green(`\nAlgorithm testing completed in ${this.algorithmStats.processingTime}ms`));
      console.log(`Memory used: ${Math.round(this.algorithmStats.memoryUsage.heapUsed / 1024 / 1024)} MB`);
      
    } catch (error) {
      console.error(colors.red(`Error initializing or running actual algorithm:`), error);
    }
  }
  
  // Convert simulation data to the format expected by the algorithm
  convertSimulationDataToAlgorithm(tradeDiscovery) {
    console.log(colors.yellow(`Converting simulation data to algorithm format...`));
    
    try {
      // Register wallets
      for (const wallet of this.simulation.wallets) {
        tradeDiscovery.registerWallet(wallet);
      }
      
      // Register NFT ownership
      for (const [nftAddress, walletAddress] of this.simulation.nftOwnership.entries()) {
        tradeDiscovery.registerNFT(nftAddress, walletAddress);
      }
      
      // Register trade preferences
      for (const [wallet, wants] of this.simulation.walletWants.entries()) {
        for (const nft of wants) {
          tradeDiscovery.addTradePreference(wallet, nft);
        }
      }
      
      console.log(colors.green(`Successfully registered ${this.simulation.wallets.length} wallets, ${this.simulation.nfts.length} NFTs, and trade preferences`));
      
    } catch (error) {
      console.error(colors.red(`Error converting simulation data:`), error);
    }
  }
  
  // Print test results
  printResults() {
    console.log(colors.blue(`\n=== SWAPS Algorithm Integration Scale Test Results ===`));
    console.log(colors.yellow(`Test Configuration:`));
    console.log(`- Wallets: ${this.config.walletCount}`);
    console.log(`- NFTs: ${this.config.nftCount}`);
    console.log(`- Algorithm max depth: ${this.config.algorithm.maxDepth}`);
    
    console.log(colors.yellow(`\nPerformance Results:`));
    console.log(`- Total processing time: ${this.algorithmStats.processingTime}ms`);
    console.log(`- Memory used: ${Math.round(this.algorithmStats.memoryUsage.heapUsed / 1024 / 1024)} MB`);
    
    console.log(colors.yellow(`\nTrade Statistics:`));
    console.log(`- Total trades found: ${this.algorithmStats.totalTradesFound}`);
    console.log(`- Direct trades (2 parties): ${this.algorithmStats.directTrades}`);
    console.log(`- Circular trades: ${this.algorithmStats.circularTrades}`);
    console.log(`- Complex multi-party trades: ${this.algorithmStats.complexTrades}`);
    console.log(`- Largest trade size: ${this.algorithmStats.largestTradeSize} parties`);
    
    console.log(colors.yellow(`\nTrades by Size:`));
    const sizes = Object.keys(this.algorithmStats.tradesBySize).sort((a, b) => parseInt(a) - parseInt(b));
    for (const size of sizes) {
      console.log(`- ${size} parties: ${this.algorithmStats.tradesBySize[size]} trades`);
    }
  }
  
  // Save the test results
  saveResults() {
    const resultsFile = path.join(this.config.outputDir, 'integration-test-results.json');
    
    const results = {
      config: this.config,
      simulationStats: this.simulation.stats,
      algorithmStats: this.algorithmStats,
      timestamp: new Date().toISOString()
    };
    
    fs.writeFileSync(resultsFile, JSON.stringify(results, null, 2));
    console.log(`Test results saved to ${resultsFile}`);
  }
}

// Command line interface
class CLI {
  constructor() {
    this.config = { ...DEFAULT_CONFIG };
    this.parseArgs();
  }
  
  parseArgs() {
    const args = process.argv.slice(2);
    
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      if (arg.startsWith('--')) {
        const [key, value] = arg.slice(2).split('=');
        
        if (key && value) {
          // Handle nested configuration
          if (key.includes('.')) {
            const [section, property] = key.split('.');
            if (this.config[section] && this.config[section][property] !== undefined) {
              this.config[section][property] = this.parseValue(value);
            }
          } else if (this.config[key] !== undefined) {
            this.config[key] = this.parseValue(value);
          }
        }
      }
    }
  }
  
  parseValue(value) {
    // Try to parse as number
    if (/^-?\d+$/.test(value)) {
      return parseInt(value, 10);
    }
    
    if (/^-?\d+\.\d+$/.test(value)) {
      return parseFloat(value);
    }
    
    // Boolean
    if (value === 'true') return true;
    if (value === 'false') return false;
    
    // Default to string
    return value;
  }
  
  async run() {
    const test = new IntegrationScaleTest(this.config);
    return await test.run();
  }
}

// Run the CLI if this is the main module
if (require.main === module) {
  const cli = new CLI();
  cli.run()
    .then(() => {
      process.exit(0);
    })
    .catch(err => {
      console.error(colors.red('Error running integration test:'), err);
      process.exit(1);
    });
}

module.exports = {
  IntegrationScaleTest
}; 